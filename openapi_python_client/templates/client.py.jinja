from types import TracebackType
from typing import Dict, Optional, Type

import attr
import httpx


{% for is_async in [False, True] %}
@attr.s(auto_attribs=True)
class {{ 'Async' if is_async else 'Sync' }}Client:
    """ A class for keeping track of data related to the API and handling the HTTP client """

    base_url: str
    token: str = attr.ib(default=None, kw_only=True)
    cookies: Dict[str, str] = attr.ib(factory=dict, kw_only=True)
    headers: Dict[str, str] = attr.ib(factory=dict, kw_only=True)
    timeout: float = attr.ib(5.0, kw_only=True)
    retries: int = attr.ib(3, kw_only=True)
    _http_client: Optional[httpx.{{ 'Async' if is_async else ''}}Client] = attr.ib(default=None, kw_only=True)

    def _init_http_client(self) -> None:
        if self._http_client is None:
            transport = httpx.{{ 'Async' if is_async else ''}}HTTPTransport(retries=self.retries)
            timeout = httpx.Timeout(timeout=self.timeout)
            self._http_client = httpx.{{ 'Async' if is_async else ''}}Client(
                headers=self.get_headers(),
                cookies=self.get_cookies(),
                transport=transport,
                timeout=timeout,
            )

    {% if is_async %}
    async def __aenter__(self) -> "AsyncClient":
    {% else %}
    def __enter__(self) -> "SyncClient":
    {% endif %}
        self._init_http_client()
        return self

    {% if is_async %}
    async def __aexit__(
    {% else %}
    def __exit__(
    {% endif %}
        self,
        exc_type: Type[BaseException] = None,
        exc_value: BaseException = None,
        traceback: TracebackType = None,
    ) -> None:
        {% if is_async %}
        await self._http_client.aclose()
        {% else %}
        self._http_client.close()
        {% endif %}

    {% if is_async %}
    async def aclose(self) -> None:
    {% else %}
    def close(self) -> None:
    {% endif %}
        if self._http_client:
            {% if is_async %}
            await self._http_client.aclose()
            {% else %}
            self._http_client.close()
            {% endif %}
            self._http_client = None

    {% if not is_async %}
    def __del__(self) -> None:
        if self._http_client:
            self._http_client.close()

    {% endif %}
    def get_headers(self) -> Dict[str, str]:
        if self.token:
           return {"Authorization": f"Bearer {self.token}", **self.headers}
        else:
          return {**self.headers}

    def get_cookies(self) -> Dict[str, str]:
        return {**self.cookies}

    def get_http_client(self) -> httpx.{{ 'Async' if is_async else ''}}Client:
        self._init_http_client()
        return self._http_client

    def with_headers(self, headers: Dict[str, str]) -> "{{ 'Async' if is_async else 'Sync'}}Client":
        """ Get a new client matching this one with additional headers """
        return attr.evolve(self, headers={**self.headers, **headers})

    def with_cookies(self, cookies: Dict[str, str]) -> "{{ 'Async' if is_async else 'Sync'}}Client":
        """ Get a new client matching this one with additional cookies """
        return attr.evolve(self, cookies={**self.cookies, **cookies})

    def with_timeout(self, timeout: float) -> "{{ 'Async' if is_async else 'Sync'}}Client":
        """ Get a new client matching this one with a new timeout (in seconds) """
        return attr.evolve(self, timeout=timeout)

    def with_token(self, token: str) -> "{{ 'Async' if is_async else 'Sync'}}Client":
        """ Get a new client matching this one with a new token authentication """
        return attr.evolve(self, token=token)
{% endfor %}
