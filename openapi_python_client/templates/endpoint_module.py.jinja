from typing import Any, Callable, Dict, List, Optional, Union, cast

import httpx
from attr import asdict

from ...client import AsyncClient, SyncClient
from ...types import UNSET, ApiRequestError, ApiHTTPStatusError, Response{% if endpoint.multipart_body_class %}, File {% endif %}

{% for relative in endpoint.relative_imports %}
{{ relative }}
{% endfor %}

{% from "endpoint_macros.py.jinja" import header_params, cookie_params, query_params, json_body, arguments, client, kwargs, parse_response, get_2xx_response_types %}

{% set ns = namespace(return_string="None") %}
{{ get_2xx_response_types(ns, endpoint) }}

{% set return_string = ns.return_string %}
{% set parsed_responses = (endpoint.responses | length > 0) %}

def _get_kwargs(
    {{ arguments(endpoint) | indent(4) }}
) -> Dict[str, Any]:
    url = "{}{{ endpoint.path }}".format(
        client.base_url
        {%- for parameter in endpoint.path_parameters -%}
        ,{{parameter.name}}={{parameter.python_name}}
        {%- endfor -%}
    )

    headers: Dict[str, Any] = {}
    cookies: Dict[str, Any] = {}

    {{ header_params(endpoint) | indent(4) }}

    {{ cookie_params(endpoint) | indent(4) }}

    {{ query_params(endpoint) | indent(4) }}

    {{ json_body(endpoint) | indent(4) }}

    {% if endpoint.multipart_body_class %}
    files = {}
    data = {}
    for key, value in multipart_data.to_dict().items():
         if isinstance(value, File):
             files[key] = value
         else:
             data[key] = value
    {% endif %}

    return {
        "url": url,
        "headers": headers,
        "cookies": cookies,
        {% if endpoint.form_body_class %}
        "data": asdict(form_data),
        {% elif endpoint.multipart_body_class %}
        "files": files,
        "data": data,
        {% elif endpoint.json_body %}
        "json": {{ "json_" + endpoint.json_body.python_name }},
        {% endif %}
        {% if endpoint.query_parameters %}
        "params": params,
        {% endif %}
    }


{% if parsed_responses %}
def _parse_response(*, response: httpx.Response) -> Callable[[], {{ return_string }}]:
    parsed_response: Union[UNSET, {{ return_string }}] = UNSET
    def parse_response() -> {{ return_string }}:
        nonlocal parsed_response
        if parsed_response != UNSET:
            return parsed_response
        if 200 <= response.status_code < 300:
            {% for response in endpoint.responses %}
            {% if 200 <= response.status_code < 300 %}
            if response.status_code == {{ response.status_code }}:
                {% if response.prop.template %}
                    {% from "property_templates/" + response.prop.template import construct %}
                {% set ind = 8 if response.prop.template != "list_property.py.jinja" else 16 %}
                {{ construct(response.prop, response.source) | indent(ind) }}
                parsed_response = {{ response.prop.name }}
                {% else %}
                parsed_response = {{ response.source }}
                {% endif %}

            if parsed_response == UNSET:
                raise ApiHTTPStatusError(
                    response,
                    f"Unmapped http code '{response.status_code}'. Maybe you are using old client version"
                )
            return parsed_response
        {% endif %}
        {% endfor %}
        raise ApiHTTPStatusError(response)
    return parse_response
{% endif %}


def _build_response(*, response: httpx.Response) -> Response[{{ return_string }}]:
    return Response(
        status_code=response.status_code,
        content=response.content,
        headers=response.headers,
        {% if parsed_responses %}
        parsed=_parse_response(response=response),
        {% else %}
        parsed= lambda _: None,
        {% endif %}
    )


def sync_detailed(
    {{ arguments(endpoint) | indent(4) }}
) -> Response[{{ return_string }}]:
    kwargs = _get_kwargs(
        {{ kwargs(endpoint) }}
    )
    try:
        response = client.get_http_client().{{ endpoint.method }}(
            **kwargs,
        )
    except httpx.HTTPStatusError as exc:
        raise ApiRequestError(exc.request)
    return _build_response(response=response)

{% if parsed_responses %}
def sync(
    {{ arguments(endpoint) | indent(4) }}
) -> {{ return_string }}:
    """ {{ endpoint.description }} """

    return sync_detailed(
        {{ kwargs(endpoint) }}
    ).parsed()
{% endif %}

async def asyncio_detailed(
    {{ arguments(endpoint, async_client=True) | indent(4) }}
) -> Response[{{ return_string }}]:
    kwargs = _get_kwargs(
        {{ kwargs(endpoint) }}
    )
    try:
        response = await client.get_http_client().{{ endpoint.method }}(
                **kwargs
        )
    except httpx.HTTPStatusError as exc:
        raise ApiRequestError(exc.request)

    return _build_response(response=response)

{% if parsed_responses %}
async def asyncio(
    {{ arguments(endpoint, async_client=True) | indent(4) }}
) -> {{ return_string }}:
    """ {{ endpoint.description }} """

    return (await asyncio_detailed(
        {{ kwargs(endpoint) }}
    )).parsed()
{% endif %}
