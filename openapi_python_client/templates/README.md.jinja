# {{ project_name }}
{{ package_description }}

## Usage
First, create a client:

### Sync

```python
from {{ package_name }} import SyncClient, SyncApi
from {{ package_name }}.models import MyDataModel
from {{ package_name }}.types import Response

with SyncClient(base_url="https://api.example.com") as client:
    api = SyncApi(client)
    my_data: MyDataModel = api.my_tag.get_my_data_model()
    # or if you need more info (e.g. status_code)
    response: Response[MyDataModel] = api.my_tag.get_my_data_model_detailed()
```

### Async

```python
from {{ package_name }} import AsyncClient, AsyncApi
from {{ package_name }}.models import MyDataModel
from {{ package_name }}.types import Response

async with AsyncClient(base_url="https://api.example.com") as client:
    api = AsyncApi(client)
    my_data: MyDataModel = await api.my_tag.get_my_data_model()
    # or if you need more info (e.g. status_code)
    response: Response[MyDataModel] = await api.my_tag.get_my_data_model_detailed()
```

### Authenticated endpoints

If the endpoints you're going to hit require authentication, you need to pass `token` to
during client creation.

### Handling errors

#### Exceptions

There are two kind of exceptions:

- `ApiError` - base class for all exceptions
    - `ApiHTTPError` - base class for HTTP exceptions
        - `ApiRequestError`: error when the request is unable to be successfully
        completed, connection errors, timeouts, etc.
        - `ApiHTTPStatusError`: status code is not 2xx response
    - `ApiResponseError`: this should not happen, it could mean that the client is not
    up to date and the API has not backward compatible changes.
        - status code is a 2xx response but it unmapped in the Api spec
        - error parsing the response, unable to convert to the data model

`ApiHTTPStatusError` and `ApiResponseError` are thrown during parsing of the request
(when non `_detailed` methods are called, or `parsed()` function is called for a
response of a `_detailed` method)

#### Retries

Built-in retries are available for connection errors, by passing `retries` parameter
during client creation.

If you need to retry for a status code, you will need to implement it by yourself,
you can use a library like `tenacity`.

### Additional info

Things to know

1. All path/query params, and bodies become method arguments.
1. If your endpoint had any tags on it, the first tag will be used as a module name for the function (my_tag above)
1. Any endpoint which did not have a tag will be in `{{ package_name }}.api.default`
